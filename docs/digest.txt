Directory structure:
└── yuki/
    ├── go.mod
    ├── go.sum
    ├── manifest.example.yaml
    ├── test-lux-manifest.yaml
    ├── .pre-commit-config.yaml
    ├── cmd/
    │   └── yuki/
    │       └── main.go
    ├── docs/
    │   ├── PRD.md
    │   └── TASKS.md
    ├── internal/
    │   ├── app/
    │   │   ├── manifest.go
    │   │   └── manifest_test.go
    │   ├── pm/
    │   │   └── scoop/
    │   │       ├── scoop.go
    │   │       └── scoop_test.go
    │   └── utils/
    ├── scripts/
    ├── .cursor/
    ├── .github/
    │   ├── CODEOWNERS
    │   ├── copilot-instructions.md
    │   ├── dependabot.yml
    │   ├── deactivated/
    │   │   ├── ci.yml
    │   │   ├── codeql.yml
    │   │   ├── dependency-review.yml
    │   │   ├── release.yml
    │   │   └── scorecard.yml
    │   ├── scripts/
    │   │   └── determine_next_version.py
    │   └── workflows/
    ├── .roo/
    └── .windsurf/
        └── rules/
            └── rules.md

================================================
File: go.mod
================================================
module github.com/nightconcept/yuki

go 1.24.3

require (
	github.com/stretchr/testify v1.10.0
	github.com/urfave/cli/v2 v2.27.6
	gopkg.in/yaml.v3 v3.0.1
)

require (
	github.com/cpuguy83/go-md2man/v2 v2.0.5 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/russross/blackfriday/v2 v2.1.0 // indirect
	github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 // indirect
)



================================================
File: go.sum
================================================
github.com/cpuguy83/go-md2man/v2 v2.0.5 h1:ZtcqGrnekaHpVLArFSe4HK5DoKx1T0rq2DwVB0alcyc=
github.com/cpuguy83/go-md2man/v2 v2.0.5/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/urfave/cli/v2 v2.27.6 h1:VdRdS98FNhKZ8/Az8B7MTyGQmpIr36O1EHybx/LaZ4g=
github.com/urfave/cli/v2 v2.27.6/go.mod h1:3Sevf16NykTbInEnD0yKkjDAeZDS0A6bzhBH5hrMvTQ=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 h1:gEOO8jv9F4OT7lGCjxCBTO/36wtF6j2nSip77qHd4x4=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1/go.mod h1:Ohn+xnUBiLI6FVj/9LpzZWtj1/D6lUovWYBkxHVV3aM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=



================================================
File: manifest.example.yaml
================================================
# Example YAML manifest for yuki
# This file demonstrates the structure and options available for the yuki manifest.
# The order of package managers determines the installation order.

# Winget packages (https://winget.run/)
winget:
  - name: "aMicrosoft.PowerToys"
  - name: "VaideoLAN.VLC"
    version: "3.0.20"  # Optional: specific version
  - name: "aMozilla.Firefox"
  - name: "Notepad++.Notepad++"
  - name: "Git.Git"

# Chocolatey packages (https://chocolatey.org/)
chocolatey:
  - name: "git"
    version: "2.45.1"  # Optional: specific version
  - name: "nodejs-lts"  # Will install the latest LTS version
  - name: "python"
    version: "3.11.0"
  - name: "docker-desktop"
  - name: "vscode"

# Scoop packages (https://scoop.sh/)
scoop:
  - name: "extras/7zip"  # Bucket prefix included in name if not in main bucket
  - name: "sumatrapdf"
    version: "3.5.2"  # Optional: specific version
  - name: "main/neovim"
  - name: "extras/vscode"
  - name: "main/curl"

# Note: The order of the sections (chocolatey, scoop, winget) determines the installation order.
# Packages within each section are installed in the order they appear.



================================================
File: test-lux-manifest.yaml
================================================
scoop:
  - name: "main/lux" 


================================================
File: .pre-commit-config.yaml
================================================
# Top-level pre-commit config for Go project
repos:
  - repo: local
    hooks:
      - id: gofmt
        name: gofmt
        entry: gofmt -l -w
        language: golang
        types: [go]
      - id: go-vet
        name: go vet
        entry: go vet ./...
        language: golang
        types: [go]
        pass_filenames: false
      - id: go-mod-tidy
        name: go mod tidy
        entry: go mod tidy -v
        language: golang
        types: [go]
        files: ^go\.(mod|sum)$
        pass_filenames: false
        always_run: true
      - id: golangci-lint
        name: golangci-lint
        entry: golangci-lint run --fix
        language: system
        types: [go]
        pass_filenames: false
  - repo: https://github.com/gitleaks/gitleaks
    rev: v8.16.3
    hooks:
      - id: gitleaks
  - repo: https://github.com/jumanjihouse/pre-commit-hooks
    rev: 3.0.0
    hooks:
      - id: shellcheck
  # - repo: https://github.com/pre-commit/pre-commit-hooks
  #   rev: v5.0.0
  #   hooks:
  #     - id: end-of-file-fixer
  #     - id: trailing-whitespace



================================================
File: cmd/yuki/main.go
================================================
package main

import (
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/nightconcept/yuki/internal/app"
	"github.com/nightconcept/yuki/internal/pm/scoop"
	"github.com/urfave/cli/v2"
)

// version is the application version, set at build time.
var version = "dev" // Default to "dev" if not set by ldflags

const maxConsecutiveScoopFailures = 3

// installScoopPackage handles the installation of a single Scoop package.
// It updates consecutiveScoopFailures and returns true if remaining packages should be skipped.
func installScoopPackage(
	pkg app.Package,
	sectionName string,
	scoopManager *scoop.ScoopManager,
	consecutiveScoopFailures *int,
	scoopSkippingActivated *bool,
) error {
	if *scoopSkippingActivated {
		fmt.Printf("  Skipping Scoop package %s due to previous consecutive failures.\n", pkg.Name)
		return nil // Indicate to continue to the next package, but it's skipped
	}

	if *consecutiveScoopFailures >= maxConsecutiveScoopFailures {
		fmt.Printf("  WARN: Reached %d consecutive Scoop installation failures. Skipping remaining Scoop packages for this run.\n", maxConsecutiveScoopFailures)
		*scoopSkippingActivated = true
		fmt.Printf("  Skipping Scoop package %s due to previous consecutive failures.\n", pkg.Name)
		return nil // Indicate to continue to the next package, but it's skipped
	}

	installArgsStr := scoopManager.BuildInstallCommand(pkg.Name, pkg.Version)
	args := strings.Fields(installArgsStr)

	fmt.Printf("  Attempting to install %s package: %s (Version: %s) using scoop...\n", sectionName, pkg.Name, pkg.Version)
	stdout, stderr, err := scoopManager.RunScoopCommand(args...)

	if err != nil {
		fmt.Printf("    ERROR installing %s: %v\n", pkg.Name, err)
		(*consecutiveScoopFailures)++
		if stderr != "" {
			fmt.Printf("      Scoop Stderr: %s\n", stderr)
		}
		if stdout != "" {
			fmt.Printf("      Scoop Stdout: %s\n", stdout)
		}
		// We return nil here because the error is handled (printed), and the apply command itself shouldn't stop
		// unless it's a manifest loading error or similar.
		return nil
	}

	fmt.Printf("    SUCCESS installing %s.\n", pkg.Name)
	*consecutiveScoopFailures = 0 // Reset failure counter on success
	if stdout != "" {
		fmt.Printf("      Scoop Stdout: %s\n", stdout)
	}
	if stderr != "" {
		fmt.Printf("      Scoop Stderr: %s\n", stderr)
	}
	return nil
}

// processManifestSection handles the processing of packages within a single manifest section.
func processManifestSection(section app.PackageManagerSection, scoopManager *scoop.ScoopManager) error {
	// Skip if the section has no packages
	if len(section.Packages) == 0 {
		return nil
	}

	// Check for specific package manager requirements before processing its packages
	if section.Name == "scoop" {
		if !scoopManager.IsScoopInstalled() {
			fmt.Println("Scoop is not installed or not found in PATH. Skipping Scoop packages.")
			return nil // Skip this entire section
		}
	}

	fmt.Printf("Processing %s packages...\n", section.Name)
	consecutiveScoopFailures := 0
	scoopSkippingActivated := false

	for _, pkg := range section.Packages {
		if section.Name == "scoop" {
			err := installScoopPackage(pkg, section.Name, scoopManager, &consecutiveScoopFailures, &scoopSkippingActivated)
			if err != nil {
				// This error isn't from package installation itself (that's handled in installScoopPackage)
				// but could be a more fundamental issue if we change installScoopPackage to return errors.
				// For now, installScoopPackage always returns nil after handling its own errors.
				return fmt.Errorf("error processing scoop package %s: %w", pkg.Name, err)
			}
		} else {
			// For other package managers, keep the old behavior (dry run print)
			if pkg.Version != "" {
				fmt.Printf("  - Would process %s package: %s, Version: %s\n", section.Name, pkg.Name, pkg.Version)
			} else {
				fmt.Printf("  - Would process %s package: %s (latest)\n", section.Name, pkg.Name)
			}
		}
	}
	return nil
}

// handleApplyCommand is the main logic for the 'apply' command.
func handleApplyCommand(c *cli.Context) error {
	manifestPath := c.Args().First()
	if manifestPath == "" {
		return fmt.Errorf("manifest path argument is required")
	}

	fmt.Printf("Loading manifest: %s\n", manifestPath)
	manifest, err := app.LoadManifest(manifestPath)
	if err != nil {
		return fmt.Errorf("failed to load manifest: %w", err)
	}

	fmt.Println("Manifest loaded. Processing packages in manifest order...")

	scoopManager := scoop.NewManager()

	for _, section := range manifest.Sections {
		err := processManifestSection(section, scoopManager)
		if err != nil {
			// Log the error and continue to the next section, or decide to stop all processing.
			// For now, let's log and continue, as per current behavior.
			fmt.Printf("ERROR processing section %s: %v\n", section.Name, err)
			// Depending on desired strictness, we might `return err` here.
		}
	}

	fmt.Println("Finished processing manifest.")
	return nil
}

// The main function, where the program execution begins.
func main() {
	appCli := &cli.App{
		Name:    "yuki",
		Usage:   "Declarative package manager for Windows",
		Version: version,
		Action: func(c *cli.Context) error {
			_ = cli.ShowAppHelp(c)
			return nil
		},
		Commands: []*cli.Command{
			{
				Name:   "apply",
				Usage:  "Applies a manifest file",
				Action: handleApplyCommand, // Use the refactored handler
			},
		},
	}

	if err := appCli.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}



================================================
File: docs/PRD.md
================================================
# yuki - Product Requirements Document (Prototype/MVP)

## 1. Introduction

- **Project Idea:** `yuki` is a Command Line Interface (CLI) tool, written in Go, designed to simplify and unify software package management on Windows. It allows users to declaratively manage software installations from a YAML manifest across three prominent package managers: Chocolatey, Scoop, and Winget. It also provides unified commands to update all software managed by these PMs and to list installed software across them.
- **Problem/Need:** Windows users often leverage multiple package managers (Chocolatey, Scoop, Winget) to access a diverse range of software. Managing these installations and updates through distinct command syntaxes and workflows is inefficient, particularly when setting up new machines or maintaining a consistent software environment based on a declarative configuration. `yuki` aims to solve this by providing a single, consistent interface for these common tasks.
- **Prototype Goal:** The main goal for this MVP is to create a functional CLI tool that:
    1. Successfully parses a user-defined YAML manifest specifying packages for Chocolatey, Scoop, and Winget.
    2. Implements an `apply` command to install software (including specific versions if requested) from the manifest using the designated package managers.
    3. Implements an `update --all` command to trigger system-wide updates across all three package managers.
    4. Implements a `list` command to display a consolidated view of packages installed by these managers.
    5. Handles errors gracefully and provides clear user feedback.
    6. Serves as a practical tool for the primary user (developer setting up/maintaining their PC) to validate its usability and approach.

## 2. Core Features / User Stories

- **Feature 1: Declarative Software Installation via Manifest (`apply` command)**
    
    - Description: Allows the user to install a list of software packages from a YAML manifest file. The manifest specifies the package name, the package manager to use, and an optional version.
    - User Action(s): User runs `yuki apply <manifest_filepath.yaml>`
    - Outcome(s):
        - `yuki` parses the YAML manifest.
        - For each package entry, `yuki` calls the specified package manager (Chocolatey, Scoop, or Winget) to install the package.
        - If a version is specified in the manifest, `yuki` attempts to install that specific version. Otherwise, the latest stable version is installed.
        - `yuki` processes package manager groups (e.g., all `chocolatey` packages, then all `scoop` packages) in the order they appear in the manifest file. Packages within each group are also processed in order.
        - Provides feedback on the success or failure of each installation.
        - Handles errors as defined (missing PM, package install failure, consecutive failure limit).
        - Outputs a summary of actions taken.
    - Command: `yuki apply <manifest_filepath>`
    - Key Inputs: Path to a valid YAML manifest file.
    - Expected Output: Console messages indicating progress, errors, and a final summary. Software listed in the manifest is installed.
- **Feature 2: System-Wide Software Update (`update --all` command)**
    
    - Description: Allows the user to update all packages managed by Chocolatey, Scoop, and Winget on their system using a single command. This command operates independently of any manifest file.
    - User Action(s): User runs `yuki update -a` or `yuki update --all`.
    - Outcome(s):
        - `yuki` executes the native "update all" commands for Chocolatey (e.g., `choco upgrade all -y`).
        - `yuki` executes the native "update all" commands for Scoop (e.g., `scoop update *`).
        - `yuki` executes the native "update all" commands for Winget (e.g., `winget upgrade --all --accept-package-agreements --accept-source-agreements`).
        - Displays output/summary from these operations.
    - Command: `yuki update -a` (alias `--all`)
    - Key Inputs: None (beyond the command itself).
    - Expected Output: Console messages indicating which package managers are being updated and their respective outputs or a summary.
- **Feature 3: Consolidated Listing of Installed Packages (`list` command)**
    
    - Description: Allows the user to see a consolidated list of software packages installed across Chocolatey, Scoop, and Winget. This command operates independently of any manifest file.
    - User Action(s): User runs `yuki list`.
    - Outcome(s):
        - `yuki` executes the native "list installed" commands for Chocolatey, Scoop, and Winget.
        - Parses the output from each package manager.
        - Displays a formatted list, clearly sectioned by package manager (Chocolatey, Scoop, Winget).
        - For each package, shows: Package Name, Installed Version, Source/Bucket (if applicable, e.g., Scoop's bucket), and Managing PM.
    - Command: `yuki list`
    - Key Inputs: None.
    - Expected Output: Formatted console output listing installed packages.

## 3. Technical Specifications

- **Primary Language(s):** Go (latest stable version, e.g., 1.22+ as of May 2025)
- **Key Frameworks/Libraries:**
    - CLI Framework: `urfave/cli` (v2 or latest stable)
    - YAML parsing: `gopkg.in/yaml.v3`
    - OS command execution: standard `os/exec`
- **Database (if any):** None for MVP.
- **Key APIs/Integrations (if any):** Direct CLI interaction with:
    - `choco.exe` (Chocolatey)
    - `scoop.exe` (Scoop)
    - `winget.exe` (Winget)
- **Deployment Target (if applicable for prototype):** Local executable for Windows (`yuki.exe`).
- **High-Level Architectural Approach:**
    - Modular CLI application built with `urfave/cli`, with commands for `apply`, `update`, and `list`.
    - Separate Go packages/modules for interacting with each underlying package manager (e.g., `internal/chocolatey`, `internal/scoop`, `internal/winget`). These modules will be responsible for:
        - Constructing the correct CLI arguments for the specific package manager.
        - Executing the command using `os/exec`.
        - Parsing the output (stdout, stderr) from the package manager CLIs into structured data where necessary (especially for the `list` command).
    - A core orchestration layer for the `apply` command to manage manifest parsing, package processing order, and error handling logic (including consecutive failure tracking).
    - YAML parsing module for the manifest file.
- **Critical Technical Decisions/Constraints:**
    - Must be able to locate and execute the `.exe` files for Chocolatey, Scoop, and Winget. Assumes they are in the system's PATH.
    - Output parsing from third-party CLIs can be fragile. Initial implementation should target known output formats of current stable versions of these managers.
    - Error handling needs to distinguish between `yuki` application errors, underlying PM not found, and errors reported _from_ the underlying PMs.
    - For the `apply` command, maintain state for consecutive failures per package manager within a single run.

## 4. Project Structure (Optional)

A typical Go CLI project structure using `urfave/cli` would be suitable.

/yuki
  /cmd
    /yuki           # Main application package
      main.go
  /internal
    /app            # Core application logic, command handlers
      apply.go
      update.go
      list.go
      manifest.go   # Manifest parsing and structure
    /pm             # Package manager interaction layer
      /chocolatey
        chocolatey.go
      /scoop
        scoop.go
      /winget
        winget.go
      common.go     # Interfaces or shared utilities for PM interaction
    /utils          # General utility functions
  go.mod
  go.sum
  README.md
  /docs
    PRD.md
    TASKS.md
  manifest.example.yaml

  - `cmd/yuki/main.go`: Entry point, CLI definition using `urfave/cli`.
- `internal/app/`: Contains the core logic for each command (`apply`, `update`, `list`) and manifest handling.
- `internal/pm/`: Contains specific logic for interacting with each package manager (building commands, executing, parsing output).
- `manifest.example.yaml`: An example manifest file.

## 5. File Descriptions (If applicable)

- **`<user_manifest>.yaml`** (User-provided, e.g., `my_setup.yaml`):
    - **Purpose:** Defines the desired state of software to be installed by the `yuki apply` command.
    - **Format:** YAML.
    - **Key Contents/Structure:**

    ```yaml
    # Example: my_setup.yaml
chocolatey:
  - name: "git"
    version: "2.45.1" # Optional: specific version
  - name: "nodejs-lts" # Installs latest LTS

scoop:
  - name: "extras/7zip" # Bucket prefix included in name if not in main
  - name: "sumatrapdf"
    version: "3.5.2" # Optional

winget:
  - name: "Microsoft.PowerToys"
  - name: "VideoLAN.VLC"
    version: "3.0.20" # Optional
    ```
    
## 6. Future Considerations / Out of Scope (for this prototype)

- **Out of Scope for Prototype:**
    - `search` command (to find packages across PMs).
    - `uninstall` command.
    - `args` field in the manifest for passing arbitrary/custom arguments to underlying PM install commands.
    - JSON manifest input format (focus on YAML for MVP).
    - `yuki` automatically installing missing package managers (Chocolatey, Scoop, Winget). It will only report if a required PM is not found.
    - Managing packages not explicitly listed for `apply` (e.g. no `yuki remove-not-in-manifest` type of command).
    - Interactive prompts during `apply` (beyond a simple yes/no for PM installation if that were in scope).
    - Advanced output parsing for all edge cases of PM outputs; MVP will focus on common/standard formats.
- **Potential Future Enhancements (Post-Prototype):**
    - Implement `search` and `uninstall` commands.
    - Support for JSON manifest format.
    - Option for `yuki` to offer to install missing package managers.
    - Configuration file for `yuki` itself (e.g., default behaviors, PM paths).
    - More robust error recovery and interactive conflict resolution.
    - Support for an `args` field in the manifest for more granular control over PM installations.
    - Parallel execution of package installations (within constraints of each PM) or PM operations (e.g., run all list commands concurrently).
    - Plugin system to support other package sources or custom script execution.

## 7. Project-Specific Coding Rules (Optional)

- **Language Version:** Go 1.22+ (or latest stable at time of development)
- **Formatting:** `gofmt` (or `goimports`) must be used.
- **Linting:** `golangci-lint` with a sensible default configuration (e.g., `golangci-lint run`).
- **Key Principles:**
    - Clarity and Readability: Code should be easy to understand and maintain.
    - Modularity: Keep concerns separated (CLI definition, app logic, PM interaction).
    - Explicit Error Handling: Handle errors explicitly; avoid panics in library/app code. Use `errors.Is`, `errors.As` where appropriate.
    - Testability: Write code that is testable. Unit tests for core logic (manifest parsing, command construction, output parsing for `list`). Mocking `os/exec` or PM interaction interfaces will be essential.
- **Naming Conventions:** Follow standard Go naming conventions (e.g., `camelCase` for local variables and internal functions, `PascalCase` for exported identifiers).
- **Testing (for prototype):**
    - Unit tests for manifest parsing.
    - Unit tests for the logic of constructing commands for each PM.
    - Unit tests for parsing output from `list` commands (using example/canned outputs).
    - Basic integration tests for CLI command invocation (e.g., ensuring commands run, help is displayed). Testing actual package installations with all PMs can be complex for automated CI but should be done manually during development.



================================================
File: docs/TASKS.md
================================================
# yuki - Task List

## Milestone 1: Core CLI Structure, Manifest Parsing, and `apply` Command (Scoop only)

**Goal:** Establish the basic `yuki` CLI application, implement manifest parsing, and achieve a functional `apply` command that can install packages from a manifest using only **Scoop** as the first supported package manager. This will validate the core workflow and error handling.

- [x] **Task 1.1:** Setup Go project structure for `yuki`
    
    - [x] Initialize Go module (`go mod init github.com/your-username/yuki`)
    - [x] Create initial directory structure (`/cmd/yuki`, `/internal/app`, `/internal/pm/scoop`, `/internal/utils`, `/docs`)
    - [x] Add `urfave/cli` and `go-yaml/yaml` dependencies.
    - [x] Verification: Project compiles. Basic `yuki --version` command works.

- [x] **Task 1.2:** Implement YAML manifest parsing
    
    - [x] Define Go structs for the manifest structure (top-level PM keys, list of package objects with `name` and optional `version`).
    - [x] Implement function to read and unmarshal the YAML manifest file (e.g., `manifest.yaml`).
    - [x] Add error handling for file not found or malformed YAML.
    - [x] Verification: Unit tests pass for parsing valid and invalid manifest examples. `yuki apply <manifest>` can successfully load and print parsed package details (dry run).

- [x] **Task 1.3:** Implement core `apply` command logic (dispatcher)
    
    - [x] Define the `apply` command structure in `urfave/cli`.
    - [x] Implement logic to iterate through PM groups in manifest file order.
    - [x] Implement logic to iterate through packages within each PM group in manifest order.
    - [x] Verification: `yuki apply <manifest>` with a dummy manifest correctly logs the packages it would process in the correct order.

- [x] **Task 1.4:** Implement **Scoop** package manager interaction for `install`
    
    - [x] Create `internal/pm/scoop/scoop.go`.
    - [x] Implement function to construct `scoop install <package_name>[@<version>]` command string.
    - [x] Implement function to execute the `scoop` command using `os/exec`.
    - [x] Capture stdout/stderr from `scoop`.
    - [x] Basic error detection (e.g., `scoop.exe` not found, non-zero exit code).
    - [x] Verification: Unit tests for command construction. Manually test installing a Scoop package using this module's function.

- [x] **Task 1.5:** Integrate **Scoop** installation into `apply` command
    
    - [x] In `apply` command logic, if `scoop` group is processed, call the Scoop interaction module for each package.
    - [x] Implement basic error reporting for `apply` (package success/failure).
    - [x] Verification: `yuki apply <manifest_with_scoop_pkgs>` successfully installs specified Scoop packages. Errors are reported.

- [x] **Task 1.6:** Implement "Missing PM" detection for **Scoop** in `apply`
    
    - [x] Before attempting `scoop` commands, check if `scoop.exe` is in PATH or executable.
    - [x] If missing, report clearly and skip Scoop packages as per PRD.
    - [x] Verification: Test `apply` with Scoop packages when `scoop.exe` is not accessible; ensure correct reporting and skipping.

- [x] **Task 1.7:** Implement consecutive failure limit for **Scoop** in `apply`
    
    - [x] Add logic to `apply` command to track consecutive installation failures for Scoop packages.
    - [x] If 3 consecutive failures occur, skip remaining Scoop packages for that run and report.
    - [x] Verification: Test with a manifest causing 3+ consecutive Scoop failures; ensure subsequent Scoop packages are skipped.

- [ ] **Task 1.8:** Basic end-of-`apply` summary
    
    - [ ] Collect results (success, failure, skip reason) for each attempted package installation.
    - [ ] Print a simple summary table/list at the end of the `apply` command.
    - [ ] Verification: Summary accurately reflects the outcome of an `apply` run with mixed results (for Scoop packages).

## Milestone 2: Extend `apply` (Installs for Choco/Winget), Implement `list` & `--dry-run` for `apply`

**Goal:** Add install support for Chocolatey/Winget to `apply`. Implement `list` command. Crucially, implement `--dry-run` for the `apply` command's install logic.

- [ ] **Task 2.1:** Implement **Chocolatey** PM interaction for `InstallPackage`
    
    - [ ] In `internal/pm/chocolatey/chocolatey.go` (create file), add `InstallPackage`.
    - [ ] Construct/execute `choco install <pkg> [--version <v>]`. "Missing PM" detection.
    - [ ] Verification: Unit tests. Integrate into `apply`. Consecutive failure logic for Choco installs.
- [ ] **Task 2.2:** Implement **Winget** PM interaction for `InstallPackage`
    
    - [ ] In `internal/pm/winget/winget.go` (create file), add `InstallPackage`.
    - [ ] Construct/execute `winget install <pkg> --version <v> --accept-...`. "Missing PM" detection.
    - [ ] Verification: Unit tests. Integrate into `apply`. Consecutive failure logic for Winget installs.
- [ ] **Task 2.3:** Implement `--dry-run` flag and logic for `apply` (Install/Update part)
    
    - [ ] Add `--dry-run` flag to `apply` command in `urfave/cli`.
    - [ ] Modify `apply` execution flow: if `--dry-run`, log intended install/update actions instead of executing.
    - [ ] Ensure PM interaction modules can signal intended actions without executing.
    - [ ] Verification: `yuki apply --dry-run <manifest>` shows packages that _would be_ installed/version-changed, without actually installing them.
- [ ] **Task 2.4:** Implement `list` command structure and PM interaction methods
    
    - [ ] Define `list` command. Add `ListInstalledPackages` method to PM modules.
    - [ ] Verification: `yuki list` runs.
- [ ] **Task 2.5:** Implement **Scoop** `ListInstalledPackages` method and parsing
    
    - [ ] In `scoop.go`, implement `ListInstalledPackages` (runs `scoop list`), parse output.
    - [ ] Verification: Unit tests. `yuki list` shows Scoop packages.
- [ ] **Task 2.6:** Implement **Chocolatey** `ListInstalledPackages` method and parsing
    
    - [ ] In `chocolatey.go`, implement `ListInstalledPackages` (runs `choco list --local-only`), parse.
    - [ ] Verification: Unit tests. `yuki list` shows Choco packages.
- [ ] **Task 2.7:** Implement **Winget** `ListInstalledPackages` method and parsing
    
    - [ ] In `winget.go`, implement `ListInstalledPackages` (runs `winget list --accept-source-agreements`), parse.
    - [ ] Verification: Unit tests. `yuki list` shows Winget packages.
- [ ] **Task 2.8:** Finalize `list` command output formatting
    
    - [ ] Consolidate lists, section by PM, format neatly.
    
    <!-- end list -->
    
    - [ ] Verification: `yuki list` output is clean, accurate.

## Milestone 3: Implement `update --all` Command, Manifest `prune` Field Parsing, and Refinements

**Goal:** Implement `update --all`. Enhance manifest parsing to include the `prune` field per PM group. Add general polishes.

- [ ] **Task 3.1:** Enhance YAML manifest parsing for `prune` field
    
    - [ ] Update Go structs for manifest to include `Prune bool` field within each PM group.
    - [ ] Ensure `prune` defaults to `false` if omitted.
    - [ ] Verification: Unit tests for parsing manifests with and without `prune` flags. Parsed data is correct.
- [ ] **Task 3.2:** Implement `update -a / --all` command structure
    
    - [ ] Define `update` command. Add `UpdateAllPackages` method to PM modules.
    - [ ] Verification: `yuki update -a` runs.
- [ ] **Task 3.3:** Implement **Scoop** `UpdateAllPackages` method
    
    - [ ] In `scoop.go`, implement (runs `scoop update *`). Capture/display output.
    - [ ] Verification: `update -a` triggers `scoop update *`.
- [ ] **Task 3.4:** Implement **Chocolatey** `UpdateAllPackages` method
    
    - [ ] In `chocolatey.go`, implement (runs `choco upgrade all -y`). Capture/display.
    - [ ] Verification: `update -a` triggers `choco upgrade all`.
- [ ] **Task 3.5:** Implement **Winget** `UpdateAllPackages` method
    
    - [ ] In `winget.go`, implement (runs `winget upgrade --all --accept-...`). Capture/display.
    - [ ] Verification: `update -a` triggers `winget upgrade --all`.
- [ ] **Task 3.6:** Add basic logging/verbose output option (`--verbose` flag)
    
    - [ ] Implement global flag and conditional detailed logging.
    - [ ] Verification: Provides more operational output.
- [ ] **Task 3.7:** Create `manifest.example.yaml` showing `prune` usage
    
    - [ ] Well-commented example file, including `prune: true/false` and comments about Winget.
    - [ ] Verification: Clear and usable.
- [ ] **Task 3.8:** Write/Update `README.md`
    
    - [ ] Include `prune` feature description, `--dry-run` usage.
    - [ ] Verification: Comprehensive and clear.

## Milestone 4: Implement Pruning (Uninstall Unmanaged based on `prune` flag) in `apply` Command

**Goal:** Enhance `apply` to identify and remove packages for Scoop/Chocolatey if their manifest section has `prune: true`. Implement Winget warning for `prune: true`. Ensure `--dry-run` shows pruning actions.

- [ ] **Task 4.1:** Design `apply` command flow for conditional pruning phase
    
    - [ ] Define steps: post-install/update phase, check `prune` flag for Choco/Scoop sections. If `prune: true` for Winget, prepare warning.
    - [ ] Verification: Flowchart or sequence diagram updated.
- [ ] **Task 4.2:** Implement `UninstallPackage` method for **Scoop**
    
    - [ ] In `scoop.go`, add `UninstallPackage` (runs `scoop uninstall <pkg>`). Error handling.
    - [ ] Verification: Unit tests. Manually test uninstalling.
- [ ] **Task 4.3:** Implement `UninstallPackage` method for **Chocolatey**
    
    - [ ] In `chocolatey.go`, add `UninstallPackage` (runs `choco uninstall <pkg> -y`). Error handling.
    - [ ] Verification: Unit tests. Manually test uninstalling.
- [ ] **Task 4.4:** Implement (stubbed/logging) `UninstallPackage` for **Winget**
    
    - [ ] In `winget.go`, add `UninstallPackage` but it should effectively be a no-op for pruning, or only log if called inappropriately for this feature. The main pruning logic will skip calling this for Winget.
    - [ ] Verification: No actual uninstall occurs.
- [ ] **Task 4.5:** Implement state comparison logic for pruning
    
    - [ ] In `internal/app/state.go` (create file) or similar: function to take manifest packages (for a specific PM) and list of all installed packages _by that PM_, return list of packages to prune for _that PM_.
    - [ ] Verification: Unit tests with various manifest/installed scenarios for a single PM.
- [ ] **Task 4.6:** Integrate pruning logic into `apply` command (Scoop & Chocolatey)
    
    - [ ] After install/update phase, for each Choco/Scoop section:
        - If `prune: true` is set in its manifest section:
            - Call `ListInstalledPackages` for that PM.
            - Call state comparison logic to get packages to prune for that PM.
            - If not `--dry-run`, call respective PM `UninstallPackage` method for each.
            - If `--dry-run`, log packages that _would be_ uninstalled.
    - [ ] Verification: `apply` with `prune: true` for Scoop/Choco correctly identifies and (if not dry run) attempts to uninstall packages. Dry run shows correct proposed uninstalls.
- [ ] **Task 4.7:** Implement Winget `prune: true` warning
    
    - [ ] In `apply` command, if a Winget section has `prune: true` in the manifest, issue a clear warning message that pruning is not supported for Winget and no action will be taken.
    - [ ] Ensure no pruning logic is triggered for Winget packages.
    - [ ] Verification: Warning is displayed when `winget: { prune: true, ... }` is in manifest. No Winget packages are marked for pruning.
- [ ] **Task 4.8:** Refine error handling and summary for `apply` (with pruning)
    
    - [ ] Ensure uninstall errors are caught and reported.
    - [ ] Update final summary to include packages successfully/unsuccessfully uninstalled (or proposed for uninstall in dry run).
    - [ ] Verification: `apply` handles uninstall errors; summary is comprehensive for all operations.
- [ ] **Task 4.9:** Thorough end-to-end testing of `apply` with pruning and `--dry-run`
    
    - [ ] Test with various manifests: `prune: true/false` for Scoop/Choco, `prune: true` for Winget.
    - [ ] Test `--dry-run` with all pruning scenarios.
    - [ ] Test actual pruning runs.
    - [ ] Verification: `apply` command behaves as a declarative state manager correctly and safely according to `prune` flags and `--dry-run`.

## Additional Tasks / Backlog (Post-MVP M1-M4)

- [ ] Implement standalone `search` command.
- [ ] Implement standalone `uninstall` command (e.g., `yuki uninstall <packagename> --manager <pm>`).
- [ ] Add support for JSON manifest input.
- [ ] Feature: Offer to install missing PMs during `apply`.
- [ ] `--force` flag for `apply` to bypass certain safety checks (e.g., if we re-introduce any other than the `prune` logic).
- [ ] Configuration file for `yuki` itself.
- [ ] Add `args` field support to manifest for custom PM arguments.
- [ ] Investigate parallel execution for PM operations.


================================================
File: internal/app/manifest.go
================================================
package app

import (
	"errors"
	"fmt"
	"io"
	"log"
	"os"

	"gopkg.in/yaml.v3"
)

// Package represents a package entry in the manifest
type Package struct {
	Name    string `yaml:"name"`
	Version string `yaml:"version,omitempty"`
}

// PackageManagerSection holds packages for a specific package manager, preserving order.
type PackageManagerSection struct {
	Name     string    `yaml:"-"` // Name is derived from the key, not from YAML content itself
	Packages []Package `yaml:",inline"`
}

// Manifest represents the top-level structure of the YAML manifest file
// It will be populated to respect the order of package manager sections.
type Manifest struct {
	Sections []PackageManagerSection
}

// UnmarshalYAML implements custom unmarshaling for the Manifest struct
// to preserve the order of package manager sections.
func (m *Manifest) UnmarshalYAML(node *yaml.Node) error {
	if node.Kind != yaml.MappingNode {
		return errors.New("manifest must be a map")
	}

	m.Sections = make([]PackageManagerSection, 0, len(node.Content)/2)

	for i := 0; i < len(node.Content); i += 2 {
		keyNode := node.Content[i]
		valueNode := node.Content[i+1]

		pmName := keyNode.Value
		var packages []Package

		// Unmarshal the packages for this section
		if err := valueNode.Decode(&packages); err != nil {
			return fmt.Errorf("failed to decode packages for %s: %w", pmName, err)
		}

		m.Sections = append(m.Sections, PackageManagerSection{
			Name:     pmName,
			Packages: packages,
		})
	}
	return nil
}

// LoadManifest reads and parses a YAML manifest file into a Manifest struct
func LoadManifest(filePath string) (*Manifest, error) {
	// Open the manifest file
	file, err := os.Open(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("manifest file not found: %s", filePath)
		}
		return nil, fmt.Errorf("failed to open manifest file: %w", err)
	}
	defer func() {
		if closeErr := file.Close(); closeErr != nil {
			// Log the error but don't fail the operation for a close error
			// since we've already read the content we need
			log.Printf("warning: failed to close manifest file: %v", closeErr)
		}
	}()

	// Read the file content
	content, err := io.ReadAll(file)
	if err != nil {
		return nil, fmt.Errorf("failed to read manifest file: %w", err)
	}

	// Parse the YAML content using the custom unmarshaler
	var manifest Manifest
	if err := yaml.Unmarshal(content, &manifest); err != nil {
		return nil, fmt.Errorf("failed to parse YAML manifest: %w", err)
	}

	// Validate the manifest
	if err := validateManifest(&manifest); err != nil {
		return nil, fmt.Errorf("invalid manifest: %w", err)
	}

	return &manifest, nil
}

// validateManifest performs basic validation on the manifest
func validateManifest(manifest *Manifest) error {
	if len(manifest.Sections) == 0 {
		return errors.New("manifest must contain at least one package manager section")
	}

	for _, section := range manifest.Sections {
		// Basic check: ensure the section has a name (derived during unmarshal)
		// and is one of the known package managers for more specific validation if needed in future.
		// For now, just check if there are packages.
		if section.Name == "" { // Should not happen with current UnmarshalYAML logic
			return errors.New("package manager section found with no name")
		}
		// if len(section.Packages) == 0 {
		// This check might be too strict if an empty section is allowed
		// return fmt.Errorf("package manager section '%s' contains no packages", section.Name)
		// }
		for i, pkg := range section.Packages {
			if pkg.Name == "" {
				return fmt.Errorf("package in section '%s' at index %d is missing required 'name' field", section.Name, i)
			}
		}
	}

	return nil
}



================================================
File: internal/app/manifest_test.go
================================================
package app

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestLoadManifest(t *testing.T) {
	tests := []struct {
		name        string
		setup       func(t *testing.T) string
		expected    *Manifest
		expectError string
	}{
		{
			name: "valid manifest with all package managers",
			setup: func(t *testing.T) string {
				tempDir := t.TempDir()
				content := `chocolatey:
  - name: "git"
    version: "2.45.1"
  - name: "nodejs-lts"

scoop:
  - name: "extras/7zip"
  - name: "sumatrapdf"
    version: "3.5.2"

winget:
  - name: "Microsoft.PowerToys"
  - name: "VideoLAN.VLC"
    version: "3.0.20"`

				filePath := filepath.Join(tempDir, "manifest.yaml")
				require.NoError(t, os.WriteFile(filePath, []byte(content), 0644))
				return filePath
			},
			expected: &Manifest{
				Sections: []PackageManagerSection{
					{
						Name: "chocolatey",
						Packages: []Package{
							{Name: "git", Version: "2.45.1"},
							{Name: "nodejs-lts", Version: ""},
						},
					},
					{
						Name: "scoop",
						Packages: []Package{
							{Name: "extras/7zip", Version: ""},
							{Name: "sumatrapdf", Version: "3.5.2"},
						},
					},
					{
						Name: "winget",
						Packages: []Package{
							{Name: "Microsoft.PowerToys", Version: ""},
							{Name: "VideoLAN.VLC", Version: "3.0.20"},
						},
					},
				},
			},
		},
		{
			name: "valid manifest with one package manager",
			setup: func(t *testing.T) string {
				tempDir := t.TempDir()
				content := `scoop:
  - name: "git"
  - name: "7zip"
    version: "1.0.0"`
				filePath := filepath.Join(tempDir, "manifest.yaml")
				require.NoError(t, os.WriteFile(filePath, []byte(content), 0644))
				return filePath
			},
			expected: &Manifest{
				Sections: []PackageManagerSection{
					{
						Name: "scoop",
						Packages: []Package{
							{Name: "git", Version: ""},
							{Name: "7zip", Version: "1.0.0"},
						},
					},
				},
			},
		},
		{
			name: "missing file",
			setup: func(t *testing.T) string {
				return "nonexistent.yaml"
			},
			expectError: "manifest file not found",
		},
		{
			name: "invalid yaml",
			setup: func(t *testing.T) string {
				tempDir := t.TempDir()
				content := `invalid: yaml: here`
				filePath := filepath.Join(tempDir, "invalid.yaml")
				require.NoError(t, os.WriteFile(filePath, []byte(content), 0644))
				return filePath
			},
			expectError: "failed to parse YAML manifest",
		},
		{
			name: "empty manifest",
			setup: func(t *testing.T) string {
				tempDir := t.TempDir()
				content := "# Empty manifest\n"
				filePath := filepath.Join(tempDir, "empty.yaml")
				require.NoError(t, os.WriteFile(filePath, []byte(content), 0644))
				return filePath
			},
			expectError: "manifest must contain at least one package manager section",
		},
		{
			name: "missing package name",
			setup: func(t *testing.T) string {
				tempDir := t.TempDir()
				content := `chocolatey:
  - version: "1.0.0"  # Missing name`
				filePath := filepath.Join(tempDir, "missing_name.yaml")
				require.NoError(t, os.WriteFile(filePath, []byte(content), 0644))
				return filePath
			},
			expectError: "package in section 'chocolatey' at index 0 is missing required 'name' field",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			filePath := tc.setup(t)

			manifest, err := LoadManifest(filePath)

			if tc.expectError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tc.expectError)
			} else {
				require.NoError(t, err)
				assert.Equal(t, tc.expected, manifest)
			}
		})
	}
}



================================================
File: internal/pm/scoop/scoop.go
================================================
package scoop

import (
	"bytes"
	"fmt"
	"os/exec"
	"strings"
)

// ScoopManager handles operations related to Scoop.
type ScoopManager struct{}

// NewManager creates a new ScoopManager.
func NewManager() *ScoopManager {
	return &ScoopManager{}
}

// IsScoopInstalled checks if scoop.exe is available in the system's PATH.
func (sm *ScoopManager) IsScoopInstalled() bool {
	_, err := exec.LookPath("scoop")
	return err == nil
}

// BuildInstallCommand constructs the scoop install command string.
// It takes a packageName and an optional version.
// If version is provided, it appends "@version" to the package name.
func (sm *ScoopManager) BuildInstallCommand(packageName string, version string) string {
	if version != "" {
		return fmt.Sprintf("install %s@%s", packageName, version)
	}
	return fmt.Sprintf("install %s", packageName)
}

// RunScoopCommand executes a given scoop command and its arguments.
// It returns the standard output, standard error, and an error if the command execution fails
// or if scoop.exe is not found in PATH.
func (sm *ScoopManager) RunScoopCommand(args ...string) (string, string, error) {
	scoopPath, err := exec.LookPath("scoop")
	if err != nil {
		return "", "", fmt.Errorf("scoop.exe not found in PATH: %w", err)
	}

	cmd := exec.Command(scoopPath, args...)

	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err = cmd.Run()

	stdoutStr := strings.TrimSpace(stdout.String())
	stderrStr := strings.TrimSpace(stderr.String())

	if err != nil {
		// err already contains information about the exit code if that's the issue
		// It could also be other errors like I/O problems with pipes, etc.
		// We'll append stderr to the error message for more context if stderr is not empty.
		if stderrStr != "" {
			return stdoutStr, stderrStr, fmt.Errorf("error running scoop command '%s %s': %w. Stderr: %s", scoopPath, strings.Join(args, " "), err, stderrStr)
		}
		return stdoutStr, stderrStr, fmt.Errorf("error running scoop command '%s %s': %w", scoopPath, strings.Join(args, " "), err)
	}

	return stdoutStr, stderrStr, nil
}



================================================
File: internal/pm/scoop/scoop_test.go
================================================
package scoop

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestScoopManager_BuildInstallCommand(t *testing.T) {
	tests := []struct {
		name        string
		packageName string
		version     string
		expectedCmd string
	}{
		{
			name:        "install package without version",
			packageName: "git",
			version:     "",
			expectedCmd: "install git",
		},
		{
			name:        "install package with version",
			packageName: "nodejs",
			version:     "18.0.0",
			expectedCmd: "install nodejs@18.0.0",
		},
		{
			name:        "install package with complex name and version",
			packageName: "extras/7zip",
			version:     "23.01",
			expectedCmd: "install extras/7zip@23.01",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			sm := NewManager()
			actualCmd := sm.BuildInstallCommand(tt.packageName, tt.version)
			assert.Equal(t, tt.expectedCmd, actualCmd)
		})
	}
}

// Note: Testing RunScoopCommand directly would require mocking os/exec or having scoop installed.
// As per task 1.4, RunScoopCommand will be manually tested.
// A more comprehensive test suite might involve an interface for command execution
// that can be mocked, or using build tags to run integration tests.






================================================
File: .github/CODEOWNERS
================================================
# This is a CODEOWNERS file.
#
# Lines starting with '#' are comments.
# Each line is a file pattern followed by one or more owners.
# These patterns follow the same rules as .gitignore.
#
# Owners can be:
# - A GitHub username (e.g., @octocat)
# - A GitHub team name (e.g., @my-org/my-team)
# - An email address (e.g., user@example.com)
#
# Order matters: the last matching pattern takes the most precedence.
#
# Example:
# *       @global-owner1 @global-owner2  # All files are owned by these users/teams
# *.js    @js-owner                      # .js files are owned by @js-owner
# /docs/  docs@example.com               # Files in the /docs/ directory are owned by docs@example.com

# All files in the repository are owned by nightconcept
* @nightconcept dark@nightconcept.net

# You can add more specific rules below if needed.
# For example, if different parts of the project have different owners:
#
# /cmd/      @nightconcept
# /internal/ @nightconcept
# /scripts/  dark@nightconcept.net



================================================
File: .github/copilot-instructions.md
================================================
# AI Project Guidelines (Condensed)

**Objective:** Define mandatory process, coding, testing, and interaction standards for AI assistance.

## 1. Preparation

* **Project Context (Session Start):** ALWAYS review key project docs: `docs/PRD.md` (architecture, goals, tech stack, versions, structure, style guide), `docs/digest.txt` (current state summary), `docs/TASKS.md` (assignments).
* **Task Prep (Before Work):**
    * ALWAYS consult `docs/TASKS.md` for your assignment. If missing, add it (concise description, `YYYY-MM-DD`).
    * ALWAYS review relevant existing code *before* suggesting changes.

## 2. Implementation Planning

**Present this plan before providing code for a task:**

* Problem description (brief).
* Solution overview (high-level).
* Implementation steps (list).
* Risks/Challenges (foreseen).

## 3. Development Workflow

* **Plan First:** Present plan (Sec 2) before coding.
* **Focus:** Target the specific task from `TASKS.md`. No unrelated refactoring unless tasked.
* **Modification Approach:**
    * Prioritize minimal, incremental, clean, elegant, idiomatic changes.
    * Explain significant suggestions (Sec 5.4).
    * Propose beneficial low-risk refactoring.
    * Avoid duplication; use helpers/modules.
    * Explain use of language strengths/pitfalls if relevant.
* **Dependencies:** No new/updated external dependencies without explicit maintainer approval (check `docs/PRD.md` for approved stack/versions). Use only approved dependencies.
* **Commits (User Task):** Follow Conventional Commits (`https://www.conventionalcommits.org/en/v1.0.0/`).
* **Manual Testing:** Provide clear user instructions for manually testing the task's changes.

## 4. Folder Structure

* **Strict Adherence:** Follow structure defined in `docs/PRD.md`.
* **Changes:** No adding/removing/relocating files/dirs without prior maintainer approval. Approved structure changes require updating `docs/PRD.md` *before* implementation.
* **Source Location:** All source code must be in `src/`.
* **Precedence:** This rule is foundational.

## 5. Coding Standards

### 5.1. General & Robustness

* Follow language best practices unless overridden by `docs/PRD.md` or these guidelines.
* Prioritize: Clarity, maintainability, efficiency.
* Consider performance & basic security.
* Implement robust error handling (language norms or `PRD.md` spec); handle errors gracefully.

### 5.2. Modularity & Structure

* Keep files focused (ideally < 500 lines); refactor large ones.
* Prefer small, single-purpose functions.
* Structure code logically (per `docs/PRD.md`) into modules.
* Use clear, consistent imports (relative for local packages). Verify paths.

### 5.3. Style & Formatting

* **Priority:** 1) `docs/PRD.md`, 2) These rules, 3) Language common practices.
* **Type Hinting:** Mandatory for functions/classes/modules (dynamic languages).
* **Indentation:** 2 spaces.
* **Function Calls:** No space: `func()` not `func ()`.
* **Line Structure:** Avoid collapsing statements if clarity suffers.
* **Scope:** Default local. More descriptive names for wider scope. Avoid single-letter vars (except iterators/tiny scope; `i` only for loops). Use `_` for ignored vars.
* **Casing:** Match current file style; else language common style. `UPPER_CASE` for constants only.
* **Booleans:** Prefer `is_` prefix for boolean functions.
* **File Headers:** Top comment: Title (descriptive, not filename) + brief purpose. No version/OS info.

### 5.4. Documentation & Comments

* **Docstrings:** Required for public functions, classes, modules (standard format).
* **Code Comments:** Explain non-obvious logic, complex algorithms, decisions (*why*, not *what*).
* **Reasoning Comments:** Use `# Reason:` for complex block rationale.
* **README Updates:** Update `docs/README.md` for core features, dependency changes, or setup/build modifications.

## 6. Testing

* **Goal:** Tests are living documentation specifying behavior. Use common language framework.
* **Behavior Specification:** Tests specify behavior. Type/scope/timing (e.g., E2E, Unit, Integration) defined in `docs/PRD.md` per project phase.
* **Location:** Place tests in `/src/test` (Lua: `/src/spec`), mirroring `src/` structure (Sec 4).
    * Ex: Tests for `src/engine/mod.js` -> `src/test/engine/mod_test.js`.
    * Ex: Lua spec for `src/engine/mod.lua` -> `src/spec/engine/mod_spec.lua`.
* **Content:** Tests clearly describe expected behavior per `PRD.md` goals for the current phase.
    * **Prototype Phase:** Primary focus on automated E2E tests validating core functionality.
* **Strategy & Coverage:** Defined in `PRD.md`, evolves with phases.
    * **Prototype Phase:** E2E priority. Comprehensive unit tests & code coverage metrics (e.g., 100% statement coverage) are **not** the focus *unless* specified in `docs/PRD.md` for a later phase demanding them.
* **Updating Tests:** Review/update tests with code changes to reflect *current* expected behavior. Fix failing/outdated tests promptly.

## 7. AI Interaction Protocols

### 7.1. Engineering Role & Audience

* **Role:** Act as a **Senior Software Engineer**.
* **Audience:** Target **Mid-Level Software Engineers** (code = best practices, clear, documented; explanations thorough; justify complex choices).

### 7.2. Interaction Guidelines

* Ask clarifying questions if needed; do not assume.
* Verify facts (libs, APIs, file paths); do not invent. Use MCP servers if available.
* Do not delete/overwrite code unless instructed or part of the defined task.
* Report significant blockers/errors *during* implementation promptly with context and suggestions.
* If a task seems complex, state potential benefit from a more advanced model **boldly** at the start (e.g., "**Suggestion: This complex refactoring might benefit from a more advanced model.**").
* Be friendly, helpful, collaborative.
* Explicitly state when task requirements are met. Mark task complete in `docs/TASKS.md`.



================================================
File: .github/dependabot.yml
================================================
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      # Check for updates to GitHub Actions every week
      interval: "weekly"

  - package-ecosystem: gomod
    directory: /
    schedule:
      interval: daily



================================================
File: .github/deactivated/ci.yml
================================================
name: Go CI
permissions:
  contents: read
  security-events: write

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    name: Test on Go ${{ matrix.go-version }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: [ '1.24' ]
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 2

      - name: Set up Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: ${{ matrix.go-version }}

      - name: Install Go tools
        run: |
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
          go install github.com/mattn/goveralls@latest

      - name: Download Go modules
        run: |
          go mod download
          go mod verify

      - name: Run govulncheck
        uses: golang/govulncheck-action@b625fbe08f3bccbe446d94fbf87fcc875a4f50ee # v1.0.4

      - name: Lint source
        run: golangci-lint run ./...

      - name: Run tests with coverage
        run: go test -v ./... -race -coverprofile=coverage.out -covermode=atomic

      - name: Upload coverage to Coveralls
        if: matrix.go-version == '1.24' # Only upload from one Go version
        env:
          COVERALLS_TOKEN: ${{ secrets.COVERALLS_REPO_TOKEN }}
        run: |
          goveralls -coverprofile=coverage.out -service=github -repotoken $COVERALLS_TOKEN



================================================
File: .github/deactivated/codeql.yml
================================================
# For most projects, this workflow file will not need changing; you simply need
# to commit it to your repository.
#
# You may wish to alter this file to override the set of languages analyzed,
# or to provide custom queries or build logic.
#
# ******** NOTE ********
# We have attempted to detect the languages in your repository. Please check
# the `language` matrix defined below to confirm you have the correct set of
# supported CodeQL languages.
#
name: "CodeQL"

on:
  push:
    branches: ["main"]
  pull_request:
    # The branches below must be a subset of the branches above
    branches: ["main"]
  schedule:
    - cron: "0 0 * * 1"

permissions:
  contents: read

jobs:
  analyze:
    name: Analyze
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        language: ["go"]
        # CodeQL supports [ $supported-codeql-languages ]
        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      # Initializes the CodeQL tools for scanning.
      - name: Initialize CodeQL
        uses: github/codeql-action/init@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17
        with:
          languages: ${{ matrix.language }}
          # If you wish to specify custom queries, you can do so here or in a config file.
          # By default, queries listed here will override any specified in a config file.
          # Prefix the list here with "+" to use these queries and those in the config file.

      # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).
      # If this step fails, then you should remove it and run the build manually (see below)
      - name: Autobuild
        uses: github/codeql-action/autobuild@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17

      # ℹ️ Command-line programs to run using the OS shell.
      # 📚 See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun

      #   If the Autobuild fails above, remove it and uncomment the following three lines.
      #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.

      # - run: |
      #   echo "Run, Build Application using script"
      #   ./location_of_script_within_repo/buildscript.sh

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17
        with:
          category: "/language:${{matrix.language}}"



================================================
File: .github/deactivated/dependency-review.yml
================================================
# Dependency Review Action
#
# This Action will scan dependency manifest files that change as part of a Pull Request,
# surfacing known-vulnerable versions of the packages declared or updated in the PR.
# Once installed, if the workflow run is marked as required,
# PRs introducing known-vulnerable packages will be blocked from merging.
#
# Source repository: https://github.com/actions/dependency-review-action
name: 'Dependency Review'
on: [pull_request]

permissions:
  contents: read

jobs:
  dependency-review:
    runs-on: ubuntu-latest
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: 'Checkout Repository'
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - name: 'Dependency Review'
        uses: actions/dependency-review-action@38ecb5b593bf0eb19e335c03f97670f792489a8b # v4.7.0



================================================
File: .github/deactivated/release.yml
================================================
name: Create Release

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: "Type of version bump (alpha, beta, rc, promote_to_final, patch, minor, major)"
        required: true
        default: "alpha"
        type: choice
        options:
          - alpha
          - beta
          - rc
          - promote_to_final
          - patch
          - minor
          - major
      draft_release:
        description: "Create as a draft release?"
        required: true
        default: "false"
        type: boolean

permissions:
  contents: read

jobs:
  determine_version:
    runs-on: ubuntu-latest
    outputs:
      next_version: ${{ steps.get_version.outputs.next_version }}
      is_prerelease: ${{ steps.get_version.outputs.is_prerelease }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0 # Required to fetch all tags

      - name: Set up Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install semver

      - name: Determine next version
        id: get_version
        env:
          BUMP_TYPE: ${{ github.event.inputs.bump_type }}
        run: python .github/scripts/determine_next_version.py

  build_and_release:
    needs: determine_version
    if: needs.determine_version.outputs.next_version != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to create releases and tags
    strategy:
      matrix:
        goos: [linux, windows, darwin]
        goarch: [amd64, arm64]
        exclude: # Add exclusions if some combinations are not needed/supported
          - goos: windows
            goarch: arm64 # Example: if windows arm64 is not a target

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Set up Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: '1.21' # As per PRD

      - name: Set version output
        id: version_output
        run: |
          echo "NEXT_VERSION=${{ needs.determine_version.outputs.next_version }}" >> $GITHUB_ENV
          echo "IS_PRERELEASE=${{ needs.determine_version.outputs.is_prerelease }}" >> $GITHUB_ENV

      - name: Build application
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          VERSION: ${{ env.NEXT_VERSION }}
        run: |
          echo "Building for $GOOS/$GOARCH with version $VERSION"
          BINARY_NAME="almd"
          if [ "$GOOS" == "windows" ]; then
            BINARY_NAME="almd.exe"
          fi
          go build -v -o $BINARY_NAME -ldflags="-X 'main.version=$VERSION'" ./cmd/almd
          ls -la $BINARY_NAME # Verify binary exists

      - name: Archive binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          VERSION_NO_V: ${{ env.NEXT_VERSION }} # Assuming NEXT_VERSION has 'v' prefix
        run: |
          VERSION_TAG=${VERSION_NO_V#v} # Remove 'v' prefix for filename
          ARCHIVE_NAME="almd_${VERSION_TAG}_${GOOS}_${GOARCH}"
          BINARY_NAME="almd"
          if [ "$GOOS" == "windows" ]; then
            BINARY_NAME="almd.exe"
            zip "${ARCHIVE_NAME}.zip" $BINARY_NAME
            echo "ASSET_NAME=${ARCHIVE_NAME}.zip" >> $GITHUB_ENV
            echo "ASSET_PATH=${ARCHIVE_NAME}.zip" >> $GITHUB_ENV
          else
            tar -czvf "${ARCHIVE_NAME}.tar.gz" $BINARY_NAME
            echo "ASSET_NAME=${ARCHIVE_NAME}.tar.gz" >> $GITHUB_ENV
            echo "ASSET_PATH=${ARCHIVE_NAME}.tar.gz" >> $GITHUB_ENV
          fi
          ls -la $ASSET_PATH # Verify archive exists

      - name: Upload artifact for this job
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: almd-binaries-${{ matrix.goos }}-${{ matrix.goarch }}
          path: ${{ env.ASSET_PATH }}

  create_release_tag:
    needs: [determine_version, build_and_release] # Ensure build_and_release completes for all platforms
    runs-on: ubuntu-latest
    if: needs.determine_version.outputs.next_version != ''
    permissions:
      contents: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Create Git Tag
        env:
          NEXT_VERSION: ${{ needs.determine_version.outputs.next_version }}
        run: |
          echo "Creating tag $NEXT_VERSION"
          git tag $NEXT_VERSION
          git push origin $NEXT_VERSION

      - name: Download all artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          path: release-artifacts # Download all artifacts to this directory
          # No specific name means download all artifacts from the run

      - name: List downloaded artifacts
        run: |
          ls -R release-artifacts

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@da05d552573ad5aba039eaac05058a918a7bf631 # v2.2.2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.determine_version.outputs.next_version }}
          name: Release ${{ needs.determine_version.outputs.next_version }}
          body: |
            Automated release for version ${{ needs.determine_version.outputs.next_version }}.
            See CHANGELOG.md for details (if available).
          draft: ${{ github.event.inputs.draft_release == 'true' }}
          prerelease: ${{ needs.determine_version.outputs.is_prerelease == 'true' }}
          files: |
            release-artifacts/almd-binaries-linux-amd64/*.tar.gz
            release-artifacts/almd-binaries-linux-arm64/*.tar.gz
            release-artifacts/almd-binaries-windows-amd64/*.zip
            release-artifacts/almd-binaries-darwin-amd64/*.tar.gz
            release-artifacts/almd-binaries-darwin-arm64/*.tar.gz



================================================
File: .github/deactivated/scorecard.yml
================================================
# This workflow uses actions that are not certified by GitHub. They are provided
# by a third-party and are governed by separate terms of service, privacy
# policy, and support documentation.

name: Scorecard supply-chain security
on:
  # For Branch-Protection check. Only the default branch is supported. See
  # https://github.com/ossf/scorecard/blob/main/docs/checks.md#branch-protection
  branch_protection_rule:
  # To guarantee Maintained check is occasionally updated. See
  # https://github.com/ossf/scorecard/blob/main/docs/checks.md#maintained
  schedule:
    - cron: '26 19 * * 2'
  push:
    branches: [ "main" ]

# Declare default permissions as read only.
permissions: read-all

jobs:
  analysis:
    name: Scorecard analysis
    runs-on: ubuntu-latest
    # `publish_results: true` only works when run from the default branch. conditional can be removed if disabled.
    if: github.event.repository.default_branch == github.ref_name || github.event_name == 'pull_request'
    permissions:
      # Needed to upload the results to code-scanning dashboard.
      security-events: write
      # Needed to publish results and get a badge (see publish_results below).
      id-token: write
      # Uncomment the permissions below if installing in a private repository.
      # contents: read
      # actions: read

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit

      - name: "Checkout code"
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: "Run analysis"
        uses: ossf/scorecard-action@f49aabe0b5af0936a0987cfb85d86b75731b0186 # v2.4.1
        with:
          results_file: results.sarif
          results_format: sarif
          # (Optional) "write" PAT token. Uncomment the `repo_token` line below if:
          # - you want to enable the Branch-Protection check on a *public* repository, or
          # - you are installing Scorecard on a *private* repository
          # To create the PAT, follow the steps in https://github.com/ossf/scorecard-action?tab=readme-ov-file#authentication-with-fine-grained-pat-optional.
          # repo_token: ${{ secrets.SCORECARD_TOKEN }}

          # Public repositories:
          #   - Publish results to OpenSSF REST API for easy access by consumers
          #   - Allows the repository to include the Scorecard badge.
          #   - See https://github.com/ossf/scorecard-action#publishing-results.
          # For private repositories:
          #   - `publish_results` will always be set to `false`, regardless
          #     of the value entered here.
          publish_results: true

          # (Optional) Uncomment file_mode if you have a .gitattributes with files marked export-ignore
          # file_mode: git

      # Upload the results as artifacts (optional). Commenting out will disable uploads of run results in SARIF
      # format to the repository Actions tab.
      - name: "Upload artifact"
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: SARIF file
          path: results.sarif
          retention-days: 5

      # Upload the results to GitHub's code scanning dashboard (optional).
      # Commenting out will disable upload of results to your repo's Code Scanning dashboard
      - name: "Upload to code-scanning"
        uses: github/codeql-action/upload-sarif@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17
        with:
          sarif_file: results.sarif



================================================
File: .github/scripts/determine_next_version.py
================================================
import os
import subprocess
import semver
import sys

def get_tags():
    try:
        result = subprocess.run(['git', 'tag', '-l', 'v*', '--sort=v:refname'], capture_output=True, text=True, check=True)
        tags = result.stdout.strip().split('\n')
        return [tag for tag in tags if tag] # Filter out empty strings if any
    except subprocess.CalledProcessError as e:
        print(f"Error fetching tags: {e}", file=sys.stderr)
        return []

def get_latest_semver(tags):
    latest_v = None
    for tag_str in reversed(tags): # Iterate from newest to oldest based on git sort
        try:
            v = semver.VersionInfo.parse(tag_str[1:]) # Remove 'v' prefix
            if latest_v is None or v > latest_v:
                latest_v = v
        except ValueError:
            # Not a valid semver tag, skip
            continue
    return latest_v

def get_latest_prerelease_for_base(tags, base_version, token):
    """
    Finds the latest prerelease tag for a given base version and token.
    Example: base_version = 0.2.0, token = 'alpha' -> finds latest v0.2.0-alpha.N
    Returns a semver.VersionInfo object or None.
    """
    latest_prerelease_v = None
    for tag_str in reversed(tags): # Assumes tags are sorted v:refname
        try:
            v = semver.VersionInfo.parse(tag_str[1:])
            if v.major == base_version.major and \
               v.minor == base_version.minor and \
               v.patch == base_version.patch and \
               v.prerelease and len(v.prerelease) == 2 and v.prerelease[0] == token:
                # Compare numeric part of the prerelease
                if latest_prerelease_v is None or v.prerelease[1] > latest_prerelease_v.prerelease[1]:
                    latest_prerelease_v = v
        except ValueError:
            # Not a valid semver tag or unexpected prerelease format
            continue
        except TypeError:
            # Handle cases where prerelease[1] might not be comparable (e.g., not an int)
            print(f"Warning: Prerelease part of tag {tag_str} is not as expected for comparison.", file=sys.stderr)
            continue
    return latest_prerelease_v

def main():
    bump_type = os.environ.get('BUMP_TYPE')
    if not bump_type:
        print("Error: BUMP_TYPE environment variable not set.", file=sys.stderr)
        sys.exit(1)

    tags = get_tags()
    latest_v = get_latest_semver(tags)

    next_v_str = ""
    is_prerelease = "true"

    if not latest_v:
        if bump_type == 'alpha':
            next_v = semver.VersionInfo(0, 2, 0, prerelease='alpha.1')
            # Check for existing tags and bump if necessary
            temp_next_v_tag = f"v{str(next_v)}"
            while temp_next_v_tag in tags: # 'tags' contains all existing v* tags
                next_v = next_v.bump_prerelease(token='alpha')
                temp_next_v_tag = f"v{str(next_v)}"
            next_v_str = str(next_v)
        else:
            print(f"Error: No existing tags found. Initial bump must be 'alpha' to start with 0.2.0-alpha.1.", file=sys.stderr)
            sys.exit(1)
    else:
        current_v = latest_v
        if bump_type == 'alpha':
            if current_v.prerelease and current_v.prerelease[0] == 'alpha':
                next_v = current_v.bump_prerelease(token='alpha')
            else: # New alpha series for current major.minor.patch or next patch
                # If current is final (e.g. 0.1.0), new alpha is 0.1.0-alpha.1
                # If current is rc (e.g. 0.1.0-rc.1), new alpha is 0.1.0-alpha.1
                # If current is beta (e.g. 0.1.0-beta.1), new alpha is 0.1.0-alpha.1
                next_v = semver.VersionInfo(current_v.major, current_v.minor, current_v.patch, prerelease='alpha.1')

            # Check for existing tags and bump if necessary
            temp_next_v_tag = f"v{str(next_v)}"
            while temp_next_v_tag in tags:
                next_v = next_v.bump_prerelease(token='alpha') # Bumps 'alpha.1' to 'alpha.2', etc.
                temp_next_v_tag = f"v{str(next_v)}"
            next_v_str = str(next_v)
        elif bump_type == 'beta':
            if current_v.prerelease and current_v.prerelease[0] == 'beta':
                next_v = current_v.bump_prerelease(token='beta')
            else: # New beta series, must come from alpha or be a new beta for a version
                # e.g., 0.1.0-alpha.2 -> 0.1.0-beta.1
                next_v = semver.VersionInfo(current_v.major, current_v.minor, current_v.patch, prerelease='beta.1')

            # Check for existing tags and bump if necessary
            temp_next_v_tag = f"v{str(next_v)}"
            while temp_next_v_tag in tags:
                next_v = next_v.bump_prerelease(token='beta')
                temp_next_v_tag = f"v{str(next_v)}"
            next_v_str = str(next_v)
        elif bump_type == 'rc':
            if current_v.prerelease and current_v.prerelease[0] == 'rc':
                next_v = current_v.bump_prerelease(token='rc')
            else: # New RC series
                next_v = semver.VersionInfo(current_v.major, current_v.minor, current_v.patch, prerelease='rc.1')

            # Check for existing tags and bump if necessary
            temp_next_v_tag = f"v{str(next_v)}"
            while temp_next_v_tag in tags:
                next_v = next_v.bump_prerelease(token='rc')
                temp_next_v_tag = f"v{str(next_v)}"
            next_v_str = str(next_v)
        elif bump_type == 'promote_to_final':
            if not current_v.prerelease:
                print(f"Error: Version {current_v} is already final. Cannot promote.", file=sys.stderr)
                sys.exit(1)
            next_v = current_v.finalize_version()
            next_v_str = str(next_v)
            is_prerelease = "false"
        elif bump_type == 'patch':
            # For patch, minor, major, we always bump from the finalized version of the *overall* latest tag.
            base_v = current_v.finalize_version()
            next_v = base_v.bump_patch()
            next_v_str = str(next_v)
            is_prerelease = "false"
        elif bump_type == 'minor':
            base_v = current_v.finalize_version()
            next_v = base_v.bump_minor()
            next_v_str = str(next_v)
            is_prerelease = "false"
        elif bump_type == 'major':
            base_v = current_v.finalize_version()
            next_v = base_v.bump_major()
            next_v_str = str(next_v)
            is_prerelease = "false"
        else:
            print(f"Error: Unknown BUMP_TYPE '{bump_type}'", file=sys.stderr)
            sys.exit(1)

    if not next_v_str.startswith('v'):
        next_v_tag = f"v{next_v_str}"
    else:
        next_v_tag = next_v_str


    print(f"Calculated next version: {next_v_tag}", file=sys.stderr)
    print(f"::set-output name=next_version::{next_v_tag}")
    print(f"::set-output name=is_prerelease::{is_prerelease}")

if __name__ == "__main__":
    main()





================================================
File: .windsurf/rules/rules.md
================================================
---
trigger: always_on
---

# AI Project Guidelines

**Objective:** Define mandatory process, coding, testing, and interaction standards for AI assistance.

## 1. Preparation

* **Project Context (Session Start):** ALWAYS review key project docs: `docs/PRD.md` (architecture, goals, tech stack, versions, structure, style guide) and `docs/digest.txt` (current state summary).

## 2. Implementation Planning

**Present this plan before providing code for a task:**

* Problem description (brief).
* Solution overview (high-level).
* Implementation steps (list).
* Risks/Challenges (foreseen).

## 3. Development Workflow

* **Plan First:** Present plan (Sec 2) before coding.
* **Focus:** Target the specific task from the given from the prompt and related files which may contain tasks and task lists. No unrelated refactoring unless tasked.
* **Modification Approach:**
    * Prioritize minimal, incremental, clean, elegant, idiomatic changes.
    * Explain significant suggestions (Sec 5.4).
    * Propose beneficial low-risk refactoring.
    * Avoid duplication; use helpers/modules.
    * Explain use of language strengths/pitfalls if relevant.
* **Dependencies:** No new/updated external dependencies without explicit maintainer approval (check `docs/PRD.md` for approved stack/versions). Use only approved dependencies.
* **Commits (User Task):** Follow Conventional Commits (`https://www.conventionalcommits.org/en/v1.0.0/`).
* **Manual Testing:** Provide clear user instructions for manually testing the task's changes.

## 4. Folder Structure

* **Strict Adherence:** Follow structure defined in `docs/PRD.md`.
* **Changes:** No adding/removing/relocating files/dirs without prior maintainer approval. Approved structure changes require updating `docs/PRD.md` *before* implementation.
* **Source Location:** All source code must be in `src/`.
* **Precedence:** This rule is foundational.

## 5. Coding Standards

### 5.1. General & Robustness

* Follow language best practices unless overridden by `docs/PRD.md` or these guidelines.
* Prioritize: Clarity, maintainability, efficiency.
* Consider performance & basic security.
* Implement robust error handling (language norms or `PRD.md` spec); handle errors gracefully.

### 5.2. Modularity & Structure

* Keep files focused (ideally < 500 lines); refactor large ones.
* Prefer small, single-purpose functions.
* Structure code logically (per `docs/PRD.md`) into modules.
* Use clear, consistent imports (relative for local packages). Verify paths.

### 5.3. Style & Formatting

* **Priority:** 1) `docs/PRD.md`, 2) These rules, 3) Language common practices.
* **Type Hinting:** Mandatory for functions/classes/modules (dynamic languages).
* **Indentation:** 2 spaces.
* **Function Calls:** No space: `func()` not `func ()`.
* **Line Structure:** Avoid collapsing statements if clarity suffers.
* **Scope:** Default local. More descriptive names for wider scope. Avoid single-letter vars (except iterators/tiny scope; `i` only for loops). Use `_` for ignored vars.
* **Casing:** Match current file style; else language common style. `UPPER_CASE` for constants only.
* **Booleans:** Prefer `is_` prefix for boolean functions.
* **File Headers:** Top comment: Title (descriptive, not filename) + brief purpose. No version/OS info.

### 5.4. Documentation & Comments

* **Docstrings:** Required for public functions, classes, modules (standard format).
* **Code Comments:** Explain non-obvious logic, complex algorithms, decisions (*why*, not *what*). Write less comments.
* **Reasoning Comments:** Use `# Reason:` for complex block rationale.
* **README Updates:** Update `docs/README.md` for core features, dependency changes, or setup/build modifications.

## 6. Testing

* **Goal:** Tests are living documentation specifying behavior. Use common language framework.
* **Behavior Specification:** Tests specify behavior. Type/scope/timing (e.g., E2E, Unit, Integration) defined in `docs/PRD.md` per project phase.
* **Location:** Place tests in `/src/test` (Lua: `/src/spec`), mirroring `src/` structure (Sec 4).
    * Ex: Tests for `src/engine/mod.js` -> `src/test/engine/mod_test.js`.
    * Ex: Lua spec for `src/engine/mod.lua` -> `src/spec/engine/mod_spec.lua`.
* **Content:** Tests clearly describe expected behavior per `PRD.md` goals for the current phase.
    * **Prototype Phase:** Primary focus on automated E2E tests validating core functionality.
* **Strategy & Coverage:** Defined in `PRD.md`, evolves with phases.
    * **Prototype Phase:** E2E priority. Comprehensive unit tests & code coverage metrics (e.g., 100% statement coverage) are **not** the focus *unless* specified in `docs/PRD.md` for a later phase demanding them.
* **Updating Tests:** Review/update tests with code changes to reflect *current* expected behavior. Fix failing/outdated tests promptly.

## 7. AI Interaction Protocols

### 7.1. Engineering Role & Audience

* **Role:** Act as a **Senior Software Engineer**.
* **Audience:** Target **Mid-Level Software Engineers** (code = best practices, clear, documented; explanations thorough; justify complex choices).

### 7.2. Interaction Guidelines

* Ask clarifying questions if needed; do not assume.
* Verify facts (libs, APIs, file paths); do not invent. Use MCP servers if available.
* Do not delete/overwrite code unless instructed or part of the defined task.
* Report significant blockers/errors *during* implementation promptly with context and suggestions.
* If a task seems complex, state potential benefit from a more advanced model **boldly** at the start (e.g., "**Suggestion: This complex refactoring might benefit from a more advanced model.**").
* Be friendly, helpful, collaborative.
* Explicitly state when task requirements are met. Mark task complete in any task lists found.



